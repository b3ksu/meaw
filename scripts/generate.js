"use strict";

const path = require("path");
const { readFile, writeFile } = require("./common.js");

const SOURCE_PATH = path.resolve(__dirname, "./EastAsianWidth.txt");
const TARGET_PATH = path.resolve(__dirname, "../src/defs.ts");

const ENCODING = "utf-8";

function readVersion(src) {
  const res = /^# EastAsianWidth-(.+).txt/.exec(src);
  if (res) {
    return res[1];
  } else {
    return "?";
  }
}

const DEFAULT_PROP_VALUE = "N";
const MIN_CODE_POINT = 0x0000;
const MAX_CODE_POINT = 0x10ffff;

function parseDef(str) {
  const [range, prop] = str.split(/\s*;\s*/, 2);
  const [startStr, endStr] = range.split(/\s*\.\.\s*/, 2);
  const start = parseInt(startStr, 16);
  const end = parseInt(endStr || startStr, 16);
  if (Number.isNaN(start) || Number.isNaN(end)) {
    throw new Error("unknown range");
  }
  return { start, end, prop };
}

function readDefs(src) {
  const defs = src
    .split(/[\r\n]+/) // split lines
    .map(line => line.replace(/^([^#]*).*$/, "$1").trim()) // strip comments
    .filter(line => line !== "") // remove empty lines
    .map(parseDef); // parse
  // complete and merge definitions
  const completeDefs = [];
  let prev = null;
  for (const def of defs) {
    if (!prev) {
      // complete head
      if (def.start !== MIN_CODE_POINT) {
        prev = {
          start: MIN_CODE_POINT,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        prev = def;
        continue;
      }
    }
    // complete
    if (prev.end + 1 !== def.start) {
      if (prev.prop === DEFAULT_PROP_VALUE) {
        prev = {
          start: prev.start,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        completeDefs.push(prev);
        prev = {
          start: prev.end + 1,
          end: def.start - 1,
          prop: DEFAULT_PROP_VALUE,
        };
      }
    }
    // merge
    if (prev.prop === def.prop && prev.end + 1 === def.start) {
      prev = {
        start: prev.start,
        end: def.end,
        prop: prev.prop,
      };
    } else {
      completeDefs.push(prev);
      prev = def;
    }
  }
  if (prev) {
    // complete tail
    if (prev.end !== MAX_CODE_POINT) {
      if (prev.prop === DEFAULT_PROP_VALUE) {
        prev = {
          start: prev.start,
          end: MAX_CODE_POINT,
          prop: DEFAULT_PROP_VALUE,
        };
      } else {
        completeDefs.push(prev);
        prev = {
          start: prev.end + 1,
          end: MAX_CODE_POINT,
          prop: DEFAULT_PROP_VALUE,
        };
      }
    }
    // push last def
    completeDefs.push(prev);
  }
  return completeDefs;
}

const HEADER = `/*
 * Generated by script. DO NOT EDIT!
 *
 * The part between BEGIN and END is derived from Unicode Data Files
 * and provided under Unicode, Inc. License Agreement.
 */`;

const IMPORT = `import { EAWDef } from "./types";`;

const BEGIN = `/* BEGIN */`;

const END = "/* END */";

function generateJs(version, defs) {
  const elems = defs
    .map(def => `  { start: ${def.start}, end: ${def.end}, prop: "${def.prop}" },`)
    .join("\n");
  const js =
    [
      HEADER,
      "",
      IMPORT,
      "",
      BEGIN,
      `export const defs: readonly EAWDef[] = [\n${elems}\n];`,
      END,
      "",
      `export const version: string = ${JSON.stringify(version)};`,
    ].join("\n") + "\n";
  return js;
}

async function generate() {
  const src = await readFile(SOURCE_PATH, { encoding: ENCODING });
  const version = readVersion(src);
  const defs = readDefs(src);
  const js = generateJs(version, defs);
  await writeFile(TARGET_PATH, js, { encoding: ENCODING });
}

generate().catch(err => {
  // eslint-disable-next-line no-console
  console.error(err);
});
